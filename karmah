#!/usr/bin/env bash
# Script Name: render-manifests
# Description: render helm manifests for applications and environments
# Author: Mark Hooijkaas
# Sourcecode: https://github.com/kisst-org/karmah/
# License: Apache License version 2.0
# Install or update to newest version with following command:
#   curl -OL https://raw.githubusercontent.com/kisst-org/karmah/refs/heads/main/karmah && chmod 755 karmah

set -eu
shopt -s extglob
script_name="${0}"


main() {
    init_argparse
    init_logging "${@}"
    init_all_modules
    read_config
    parse_options "${@}"
    $command
}


#####################################
# argparse.lib

init_argparse() {
    declare -gA aliases=()
    declare -ga parsed_args=()

    declare -g def_paths=""
    declare -g subdirs=""
    declare -g to_dir=tmp/manifests
    declare -ga updates=()
    declare -gA command_help=()
    declare -gA action_help=()
    declare -g action_list=""
    declare -g command

    add_command aliases "show all defined aliases"
}

add_command() {
    command_help["$1"]="${2:-no help specfied}"
}
add_action() {
    action_help["$1"]="${2:-no help specfied}"
}



replace_aliases() {
    for arg in "${@}"; do
        local al="${aliases[$arg]:-none}"
        if [[ "$al" != none ]]; then
            replaced=true
            parsed_args+=($al)
        else
            parsed_args+=("$arg")
        fi
    done
}

parse_options() {
    local replaced=false
    replace_aliases "${@}"
    set -- "${parsed_args[@]}"
    log_level=$log_level_info
    while [[ $# > 0 ]]; do
        arg=$1
        case $arg in
            -h|--help|help) show_help; exit 0;;
            --debug)        set -x;;
            -s|--subdir)    subdirs+=" $2";      shift;;
            -t|--to)        to_dir="$2";         shift;;
            -w|--with)      with_dir="$2";       shift;;
            -a|--action)    action_list+="$2";   shift;;
            -u|--update)    updates+=("\"$2\""); shift;;
            *)
                parse_result=0
                parse_args_logging "$@"
                if [[ "$parse_result" > 0 ]]; then
                    shift $(( "$parse_result" - 1))
                else
                    if [[ "${command_help["$arg"]:-none}" != none  ]]; then
                        command="run_command_$arg"
                    elif [[ "${action_help["$arg"]:-none}" != none  ]]; then
                        action_list+="$arg"
                    elif [[ -f ${arg} ]]; then def_paths+=" ${arg}"
                    elif [[ -d ${arg} ]]; then def_paths+=" ${arg%%/}" # remove a trailing /
                    else
                        echo unknown argument ${arg}, should be a command, file or directory
                        show_help
                        exit 1
                    fi
                fi
        esac
        shift
    done
    verbose COMMAND $(basename $0) ${parsed_args[@]}
}

#####################################
# config.lib

read_config() {
    : ${RENDER_CONFIG_FILE:=~/.config/karmah/config}
    if [[ -f ${RENDER_CONFIG_FILE} ]]; then
        source ${RENDER_CONFIG_FILE}
    fi
    if [[ -d config.d ]] && "${use_config_d:-true}"; then
        for inc in config.d/*.config; do
            source $inc
        done
    fi
    default_renderer=${RENDER_DEFAULT_RENDERER:-helm}
}

#####################################
# copy-files.lib

render_copy-files() {
    def_file_dir=$(dirname "${def_file}")
    files_list="$def_file_dir"/${env}/files/*.yaml
    verbose_cmd cp -f ${files_list} ${output_dir}
}

apply_update_copy-files() { :; }

#####################################
# git.lib

init_module_git() {
    declare -g used_files=""
    declare -g git_pulled=false
    add_action git-diff "shows the changes to source and rendered manifests with git"
    add_action git-add "adds the changes to source and rendered manifests to git, for committing"
    add_action git-commit "commits the changes to source and rendered manifests to git"
}

run_action_ask() {
    local answer
    read -p "do you want to continue?" answer
}

run_action_git-pull() {
    verbose_cmd git pull
}

run_action_git-diff() {
    run_action_render
    info git-diff ${env} ${appname} to ${output_dir}
    if $(log_is_verbose); then
        verbose_cmd git diff -- ${used_files} ${output_dir} || true
    else
        verbose_cmd git diff -- ${used_files} ${output_dir} | grep -E '^[+-] |^---' || true
    fi
}

run_action_git-add() {
    run_action_render
    info git-add ${env} ${appname} to ${output_dir}
    verbose_cmd git add "${used_files} ${output_dir}"
}

run_action_git-status() {
    run_action_render
    git status
}


run_action_git-commit() {
    run_action_git-add
    info git commit -m "${action} of ${appname} on ${env}" "${used_files} ${output_dir}"
}

#####################################
# helm.lib

init_helm_vars() {
    local def_file_dir=$(dirname ${def_file})
    local parent_dir=$(dirname "$def_file_dir")

    helm_value_files=("helm/env-value-files/values-env-${env}.yaml")
    helm_value_files+=("$parent_dir/values*${appname}.yaml")
    helm_value_files+=("$def_file_dir/values*${appname}-${env}.yaml")

    helm_command="helm template --namespace ${namespace}" # TODO: --create-namespace does not create yaml for namespace
    appdef_vars+="helm_command helm_value_files helm_charts"
}

render_helm() {
    helm_release=$appname # this is probably not really used with helm template
    local f
    for f in ${helm_value_files[@]}; do helm_command+=" -f ${f}"; done
    helm_command+=" $helm_release"
    used_files="${helm_value_files[@]}"
    for ch in ${helm_charts//,/ }; do
        local chart=${ch//@*}
        if [[ $ch == $chart ]]; then
            used_files+=" $ch"
            verbose_pipe split_into_files "$helm_command $ch"
        else
            local repo=${ch//*@}
            verbose_pipe split_into_files "$helm_command --repo $repo $chart --version $chart_version"
        fi
    done
}

apply_update_helm() {
    local f=${helm_value_files[-1]}
    verbose applying update "$1" to "$f"
    case "$1" in
        yq:*)
            local expr="${1#yq:}"
            expr=${expr//=/=\"}\"  # add quotes around =...
            verbose_cmd yq -i "${expr}" "$f"
        ;;
        *)
            echo unknown update "$1";
            exit 1
        ;;
    esac
}

#####################################
# help.lib

show_help() {
cat <<EOF
$(basename ${script_name}) [ option | command | path ]...

Options:
  -h|--help|help      show this help and exit
  -v|--verbose        give more output
  -s|--show-cmd       show the commands being executed
  -q|--quiet          no output
  -n|--dry-run        do not execute the actual commands
  -s|--subdir <dir>   add subdir to list of subdirs (can be comma separated list)
  -t|--to <path>      other path to render to (default is tmp/manifests)
  -w|--with <path>    used for comparison between two manifest trees
  -u|--update <expr>  update source files before rendering
Commands:
EOF
for key in $(printf "%s\n" ${!command_help[@]} | sort); do
  printf "  %-13s %s\n" $key "${command_help[$key]}"
done
cat <<EOF
Paths:
  Each path defines an application definition, that will be sourced,
  This can either be a file, or a directory that contains exactly 1 file with a name '*.def'.
  When one or more --subdirs are specfied, these will be append to the path

Note:
  Options, commands and paths can be mixed freely
  If multiple commands are given, only last command will be used
EOF
}

run_command_aliases() {
echo Aliases:
for key in $(printf "%s\n" ${!aliases[@]} | sort); do
    printf "  %-13s %s\n" $key "${aliases[$key]}"
done |sort -k2 -k1
}

#####################################
# kapp.lib

init_module_kapp() {
    add_command install-kapp "install the tool kapp from carvel"
    add_action kapp-plan "show what resources will be updated"
    add_action kapp-diff "show what resources will be updated, including detailed diffs"
    add_action kapp-deploy "deploy the application with kapp"
}

run_command_install-kapp() {
    if [ -x "$(command -v kapp)" ]; then
        info kapp already installed
        #return 0
    fi
    info Installing kapp...
    local binary_type=linux-amd64
    local version=v0.64.2
    local dst_dir=~/.local/bin

    if (( $log_level >= $log_level_verbose )); then
        verbose_cmd curl    -L https://github.com/carvel-dev/kapp/releases/download/${version}/kapp-${binary_type} -o ${dst_dir}/kapp
    else
        verbose_cmd curl -s -L https://github.com/carvel-dev/kapp/releases/download/${version}/kapp-${binary_type} -o ${dst_dir}/kapp
    fi
    chmod +x ${dst_dir}/kapp
    verbose Installed ${dst_dir}/kapp ${version}
}

kapp_options() {
    local cl=$(kube_cluster)
    local cfg=${kubeconfig[$cl]:-default}
    local opt=""
    if [[ $cfg != default ]]; then
        opt="--kubeconfig $cfg " # extra space at end
    fi
    opt+="--kubeconfig-context ${kubecontext[$cl]} -n ${namespace} -a ${appname} -f ${output_dir}"
    echo $opt
}

run_action_kapp-diff() {
    run_action_render
    verbose_cmd kapp deploy $(kapp_options) --diff-run --diff-changes
}

run_action_kapp-plan() {
    run_action_render
    verbose_cmd kapp deploy $(kapp_options) --diff-run
}

run_action_kapp-deploy() {
    run_action_render
    if ! kubectl $(kubectl_options) get ns $namespace >/dev/null 2>&1; then
        verbose_cmd kubectl $(kubectl_options) create ns $namespace
    fi
    verbose_cmd kapp deploy $(kapp_options)
}

#####################################
# kube.lib

init_module_kube() {
    declare -Ag cluster
    declare -Ag kubeconfig
    declare -Ag kubecontext
    add_action kube-get "get current manifests from cluster to --to <path> (default) deployed/manifests"
    add_action kube-apply "apply rendered manifests with cluster (kubectl apply)"
    add_action kube-diff "compare rendered manifests with cluster (kubectl diff)"
}

kube_cluster() {
    local cl=${cluster[$env,$appname]:-${cluster[$env]:-undefined}}
    if [[ $cl == undefined ]]; then
        error unknown cluster for $env
        exit 1
    fi
    echo $cl
}

kubectl_options() {
    local cl=$(kube_cluster)
    local cfg=${kubeconfig[$cl]:-default}
    local opt=""
    if [[ $cfg != default ]]; then
        opt="--kubeconfig $cfg " # extra space at end
    fi
    opt+="--context ${kubecontext[$cl]}"
    echo $opt
}

filter-kube-diff-output() { grep -E '^[+-] |^---'; }
run_action_kube-diff() {
    run_action_render
    info kube-diff ${env} ${appname} to ${output_dir}
    if $(log_is_verbose); then
        verbose_cmd kubectl diff $(kubectl_options) -f $output_dir || true
    else
        verbose_pipe filter-kube-diff-output kubectl diff $(kubectl_options) -f $output_dir || true
    fi
}

run_action_kube-apply() {
    run_action_kube-diff
    info kube apply $output_dir
    verbose_cmd kubectl apply $(kubectl_options) -f $output_dir
}

split_kubectl_output_into_files() {
    yq  '.items.[]' -s \"$output_dir/\"'+ (.kind | downcase) + "_" + .metadata.name + ".yaml"'
}

run_action_kube-get-manifests() {
    info kube get manifests  ${env} ${appname} to ${output_dir}
    verbose_cmd rm -rf ${output_dir}
    verbose_cmd mkdir -p ${output_dir}
    verbose_pipe split_kubectl_output_into_files kubectl ${kubectl_options[$env]} -n "${namespace}" get deploy,svc,sts,cm,ingress -o yaml
    ignore_files=configmap_kube-root-ca.crt.yaml
    ignore_files+=" deployment_ingress-nginx-controller.yaml"
    ignore_files+=" service_ingress-nginx-controller-admission.yaml"
    ignore_files+=" service_ingress-nginx-controller.yaml"
    for f in ${ignore_files}; do
        rm -f "${output_dir}/$f"
    done
    for f in "${output_dir}"/*.yaml; do
         yq -i 'del(.metadata.annotations.["kubectl.kubernetes.io/last-applied-configuration"])' "${f}"
         yq -i 'del(.metadata.uid)' "${f}"
         yq -i 'del(.metadata.resourceVersion)' "${f}"
         yq -i 'del(.metadata.creationTimestamp)' "${f}"
    done
}

#####################################
# kustomize.lib

render_kustomize() {
    local command="kubectl kustomize --enable-helm"
    #used_files+=" $helm_chart_dir/$ch"
    verbose_pipe split_into_files "$command $(dirname ${def_file})"
}

#####################################
# logging.lib

init_logging() {
    declare -gi log_level_fatal=0
    declare -gi log_level_error=10
    declare -gi log_level_warn=20
    declare -gi log_level_info=30
    declare -gi log_level_verbose=40
    declare -gi log_level_debug=50
    declare -gi log_level=$log_level_info
    declare -g  log_commands=false
    parse_loglevel "$@"
}

parse_args_logging() {
    case "$1" in
        -v|--verbose)   log_level+=10;                 parse_result=1;;
        -vv)            log_level+=20;                 parse_result=1;;
        -q|--quiet)     log_level=$log_level_warn;     parse_result=1;;
        -C|--show-cmd)  log_commands=true;             parse_result=1;;
        -n|--dry-run)   dry_run=true;                  parse_result=1;;
    esac
}

log_is_error()   { (( ${log_level} >= ${log_level_error} )) }
log_is_warning() { (( ${log_level} >= ${log_level_warning} )) }
log_is_info()    { (( ${log_level} >= ${log_level_info} )) }
log_is_verbose() { (( ${log_level:-30} >= ${log_level_verbose:-40} )) }
log_is_debug()   { (( ${log_level} >= ${log_level_debug} )) }

error()   { if $(log_is_error) ;   then printf "ERROR "; printf "%s " "${@}"; echo; fi }
warning() { if $(log_is_warning) ; then printf "WARN "; printf "%s " "${@}"; echo; fi }
info()    { if $(log_is_info) ;    then printf "# ";  printf "%s " "${@}"; echo; fi }
verbose() { if $(log_is_verbose) ; then printf "## "; printf "%s " "${@}"; echo; fi }
debug()   { if $(log_is_debug) ;   then printf "### ";  printf "%s " "${@}"; echo; fi }

verbose_cmd() {
    if (( $log_level >= $log_level_verbose )); then
        printf "    "; echo "${@}";
    elif $log_commands; then
        printf "    "; echo "${@}";
    fi
    if ! ${dry_run:-false}; then
        cmd=$1; shift
        $cmd "${@}"
    fi
}

verbose_pipe() {
    pipe=$1
    shift
    if (( $log_level >= $log_level_verbose )); then
        printf "    "; echo "${@}" \| $pipe;
    elif $log_commands; then
        printf "    "; echo "${@}" \| $pipe;
    fi
    if ! ${dry_run:-false}; then
        cmd=$1; shift
        $cmd "${@}" | $pipe
    fi
}


parse_loglevel() {
    for arg in "$@"; do
        parse_args_logging "${arg}" >/dev/null
    done
}

#####################################
# module.lib

load_module() {
    file="$1"
    shift
    if [[ ${module_files["${file}"]:-} == loaded ]]; then
        verbose skipping module file "${file}" already loaded
        return 0
    fi
    module_files["${file}"]=loaded
    local filename="$(basename "${file}")"
    local module="${filename%%.lib}"
    verbose loading module "${module}" from "${file}"
    source "${file}"
}

use_module() {
    local module="$1"
    if ${module_needs_init["${module}"]:-true}; then
        verbose running init module for "${module}"
        init_module_${module}
        module_needs_init["${module}"]=false
    fi
}

init_all_modules() {
    declare -g modules=""
    declare -gA module_needs_init=()
    declare -gA module_files=()
    modules=$(set | grep '^init_module_'| sed -e 's/init_module_//' -e 's/ *()//')
    for m in $modules; do
        use_module $m
    done
}

#####################################
# render.lib

init_module_render() {
    add_action update "update source files with expressions from --update"
    add_action render "render manifests to --to <path> (default tmp/manifests)"
    add_action compare "render manifests to --to <path> (default tmp/manifests) and then compare with --with path (default deployed/manifests)"
    add_command "forall" "run actions for all paths"
    command=run_command_forall
}

run_action_update() {
    if [[ ${#updates[@]} == 0 ]]; then
        verbose skipping updates
        return 0
    fi
    info updating ${env} ${appname}
    for up in ${updates[@]}; do
        verbose applying update "$up"
        apply_update_$renderer "$up"
    done
}

run_action_render() {
    run_action_update
    info rendering ${env} ${appname} to ${output_dir} with ${renderer}
    verbose_cmd rm -rf ${output_dir}
    verbose_cmd mkdir -p ${output_dir}
    for r in ${renderer//,/ }; do
        render_$r
    done
 }


render_post-render() { $post_render_func; }

run_action_compare() {
    run_action_render

    olddir=${output_dir}
    local newdir=${with_dir:-deployed/manifests}/${env}/${appname}
    info comparing ${env} ${appname}: ${output_dir} with ${newdir}

    if ${clean_before_compare:-true}; then
        verbose_cmd mkdir -p tmp/$(dirname $newdir)
        verbose_cmd cp -r $newdir tmp/$(dirname $newdir)
        newdir=tmp/${newdir}
        pre_diff_cleanup $newdir $olddir
    fi
    verbose_cmd diff -r $newdir $olddir || true
}

basic_cleanup () {
    verbose removing comments
    sed -i -e '/^ *#/d' $1/*.yaml $2/*.yaml
    verbose removing quotes around values starting or ennding with text
    sed -i -e 's/: "\([a-zA-Z].*\)"$/: \1/' $1/*.yaml $2/*.yaml
    sed -i -e 's/: "\([a-zA-Z0-9].*[a-zA-Z]\)"$/: \1/' $1/*.yaml $2/*.yaml
}

pre_diff_cleanup() {
    basic_cleanup $1 $2
}

split_into_files() {
    yq -P 'sort_keys(..)' | yq -s \"$output_dir/\"'+ (.kind | downcase) + "_" + .metadata.name + ".yaml"'
    rm -f ${output_dir}/_.yaml
}


#####################################
# run actions for all app/envs

run_command_forall() {
    for path in $def_paths; do
        if [[ -f $path ]]; then
            def_file=$path
            run_actions ${action_list:-render}
        elif [[ -z ${subdirs:-} ]]; then
            def_file=($path/*.def) # use array for globbing
            run_actions ${action_list:-render}
        else
            for sd in ${subdirs//,/ }; do
                def_file=($path/$sd/*.def)  # use array for globbing
                run_actions ${action_list:-render}
            done
        fi
    done
}

init_appdef_basic() {
    appdef_vars+=""
}

run_actions() {
    renderer=""
    action_list="$@"
    local appdef_type
    local appdef_vars="appdef_type appdef_vars appname env"
    if [[ -f "${def_file}" ]]; then
        verbose loading ${def_file}
        source ${def_file}
        init_appdef_${appdef_type:-basic}
        output_dir="${to_dir}/${env}/${appname}"
        for action in ${action_list//,/ }; do
            verbose running $action with ${output_dir} for ${env} ${appname}
            run_action_$action;
        done
        # cleanup of any vars set in init_appdef_...
        verbose unsetting $appdef_vars
        unset $appdef_vars
    else
        info skipping $def_file
    fi
}

#####################################
main "${@}"

#####################################
# pre.bash

#####################################
# argparse.bash

init_argparse() {
    declare -gA aliases=()
    declare -ga parsed_args=()

    declare -g karmah_paths=""
    declare -g subdirs=""
    declare -ga updates=()
    declare -ga action_help=()
    declare -ga command_help=()
    declare -ga option_help=()

    declare -gA parse_arg_func=()
    declare -g action_list=""
    declare -g command
}

add_option() {
    local short=$1
    local name=$2
    local arg=$3
    shift 3
    local help=$@
    parse_arg_func[--$name]=parse_option_$name
    if [[ -z $short ]]; then
        name="--$name"
    else
        parse_arg_func[-$short]=parse_option_$name
        name="-$short|--$name"
    fi
    [[ -z $arg ]] || name+=" <$arg>"
    option_help+=("$(printf "  %-20s %s\n" "$name" "$help")")
}

parse_set_command() { command=run_command_$1; }
add_command() {
    local name=$1
    shift 1
    local help=$@
    parse_arg_func[$name]=parse_set_command
    command_help+=("$(printf "  %-13s %s\n" "$name" "$help")")
}

parse_append_action() { action_list+=$1;  }
parse_append_action_with_args() { action_list+=$1; collect_unknown_args=true; }
add_action() {
    local name=$1
    shift 1
    if [[ ${1:-} == --collect ]]; then
        shift
        parse_arg_func[$name]=parse_append_action_with_args
    else
        parse_arg_func[$name]=parse_append_action
    fi
    local help="$@"
    action_help+=("$(printf "  %-13s %s\n" "$name" "$help")")
}

parse_arg() {
    local name=$1
    local func=${parse_arg_func[$name]:-}
    if [[ ! -z $func ]]; then
        parse_result=1
        $func "$@"
    fi
}


replace_aliases() {
    for arg in "${@}"; do
        local al="${aliases[$arg]:-none}"
        if [[ "$al" != none ]]; then
            replaced=true
            parsed_args+=($al)
        else
            parsed_args+=("$arg")
        fi
    done
}

parse_options() {
    local replaced=false
    local collect_unknown_args=false
    declare -g extra_args=""
    replace_aliases "${@}"
    set -- "${parsed_args[@]}"
    log_level=$log_level_info
    while [[ $# > 0 ]]; do
        arg=$1
        parse_result=0
        parse_arg "$@";
        if [[ $arg = -vv ]]; then # TODO: parse multiple short options
            log_level+=20;
        elif [[ "$parse_result" > 0 ]]; then
            shift $(( "$parse_result" - 1))
        else
            if [[ -f ${arg} ]]; then karmah_paths+=" ${arg}"
            elif [[ -d ${arg} ]]; then karmah_paths+=" ${arg%%/}" # remove a trailing /
            elif $collect_unknown_args; then extra_args+=" $arg"
            else
                echo unknown argument ${arg}, should be an option, action or path
                show_short_help
                exit 1
            fi
        fi
        shift
    done
    verbose COMMAND $(basename $0) ${parsed_args[@]}
}

#####################################
# config.bash

read_config() {
    : ${RENDER_CONFIG_FILE:=~/.config/karmah/config}
    if [[ -f ${RENDER_CONFIG_FILE} ]]; then
        source ${RENDER_CONFIG_FILE}
    fi
    if [[ -d config.d ]] && "${use_config_d:-true}"; then
        for inc in config.d/*.config; do
            source $inc
        done
    fi
    default_renderer=${RENDER_DEFAULT_RENDERER:-helm}
}

#####################################
# logging.bash

init_logging() {
    declare -gi log_level_fatal=0
    declare -gi log_level_error=10
    declare -gi log_level_warn=20
    declare -gi log_level_info=30
    declare -gi log_level_verbose=40
    declare -gi log_level_debug=50
    declare -gi log_level=$log_level_info
    declare -g  log_commands=false
    parse_loglevel "$@"
}

init_bash_module_logging() {
    use_module help
    add_option v verbose  ""    give more output
    add_option C show-cmd ""    show the commands being executed
    add_option q quiet    ""    show no output
    add_option n dry-run  ""    do not execute the actual commands
    add_option "" debug   ""    show detailded debug info
    aliases[plan]="--quiet --dry-run --show-cmd"
}

# TODO -vv
parse_option_verbose()   { log_level+=10; }
parse_option_quiet()     { log_level=$log_level_warn; }
parse_option_show-cmd()  { log_commands=true; }
parse_option_dry-run()   { dry_run=true; }
parse_option_debug()     { set -x; }


log_is_error()   { (( ${log_level} >= ${log_level_error} )) }
log_is_warn()    { (( ${log_level} >= ${log_level_warn} )) }
log_is_info()    { (( ${log_level} >= ${log_level_info} )) }
log_is_verbose() { (( ${log_level:-30} >= ${log_level_verbose:-40} )) }
log_is_debug()   { (( ${log_level} >= ${log_level_debug} )) }

error()   { if $(log_is_error) ;   then printf "ERROR "; printf "%s " "${@}"; echo; fi }
warn()    { if $(log_is_warn) ;    then printf "WARN "; printf "%s " "${@}"; echo; fi }
info()    { if $(log_is_info) ;    then printf "# ";  printf "%s " "${@}"; echo; fi }
verbose() { if $(log_is_verbose) ; then printf "## "; printf "%s " "${@}"; echo; fi }
debug()   { if $(log_is_debug) ;   then printf "### ";  printf "%s " "${@}"; echo; fi }

verbose_cmd() {
    if (( $log_level >= $log_level_verbose )); then
        printf "    "; echo "${@}";
    elif $log_commands; then
        printf "    "; echo "${@}";
    fi
    if ! ${dry_run:-false}; then
        cmd=$1; shift
        $cmd "${@}"
    fi
}

verbose_pipe() {
    pipe=$1
    shift
    if (( $log_level >= $log_level_verbose )); then
        printf "    "; echo "${@}" \| $pipe;
    elif $log_commands; then
        printf "    "; echo "${@}" \| $pipe;
    fi
    if ! ${dry_run:-false}; then
        cmd=$1; shift
        $cmd "${@}" | $pipe
    fi
}


parse_loglevel() {
    for arg in "$@"; do
        if [[ $arg == -v ]]; then log_level+=10; fi
    done
}

#####################################
# module.bash

load_module() {
    file="$1"
    shift
    if [[ ${module_files["${file}"]:-} == loaded ]]; then
        verbose skipping module file "${file}" already loaded
        return 0
    fi
    module_files["${file}"]=loaded
    local filename="$(basename "${file}")"
    local module="${filename%%.lib}"
    verbose loading module "${module}" from "${file}"
    source "${file}"
}

use_module() {
    local module="$1"
    if ${module_needs_init["${module}"]:-true}; then
        debug running init module for "${module}"
        init_bash_module_${module}
        module_needs_init["${module}"]=false
    fi
}

init_all_modules() {
    declare -g modules=""
    declare -gA module_needs_init=()
    declare -gA module_files=()
    use_module logging
    modules=$(set | grep '^init_bash_module_'| sed -e 's/init_bash_module_//' -e 's/ *()//')
    for m in $modules; do
        use_module $m
    done
}

#####################################
# copy-files.bash

render_copy-files() {
    files_list="$karmah_dir"/files/*.yaml
    verbose_cmd cp -f ${files_list} ${output_dir}
}

#####################################
# git.bash

init_bash_module_git() {
    use_module render
    declare -g used_files=""
    declare -g git_pulled=false
    add_action git-diff "shows the changes to source and rendered manifests with git"
    add_action git-add "adds the changes to source and rendered manifests to git, for committing"
    add_action git-commit "commits the changes to source and rendered manifests to git"

    add_option m message  msg   set message to us with git commit
    global_vars+=" used_files"  # TODO: git_commit_message
}

parse_option_message()   { git_commit_message="$2";   parse_result=2; }

run_action_git-pull() {
    verbose_cmd git pull
}

run_action_git-diff() {
    info git-diff ${target} to ${output_dir}
    if $(log_is_verbose); then
        verbose_cmd git diff -- ${used_files} ${output_dir} || true
    else
        verbose_cmd git diff -- ${used_files} ${output_dir} | grep -E '^[+-]|^---' || true
    fi
}

run_action_git-add() {
    info git-add ${target} to ${output_dir}
    verbose_cmd git add ${used_files} ${output_dir}
}

run_action_git-status() {
    git status
}


run_action_git-commit() {
    run_action_git-add
    : ${git_commit_message:=${action} of ${target}}
    verbose_cmd git commit -m "${git_commit_message}" ${used_files} ${output_dir}
}

#####################################
# helm.bash

init_bash_module_helm() {
    use_module render
    add_action helm-install "run helm-install"
    global_vars+=" helm_template_command helm_value_files helm_charts helm_install_command helm_atomic_wait"
    global_arrays+="helm_update_version_path helm_update_replicas_path"
}

add_optional_helm_values_file() {
    local f=($1)
    if [[ -f $f ]]; then
        debug adding values file $f
        helm_value_files+=("$f")
    else
        debug skipping values file $f
    fi
}

init_helm_vars() {
    local parent_dir=$(dirname "$karmah_dir")
    add_optional_helm_values_file "$common_dir/values*.yaml"
    add_optional_helm_values_file "$karmah_dir/values*.yaml"
}

calc_helm_command() {
    local chart=$1
    shift
    local cmd=$@
    local f
    local helm_release=$(basename $target)
    for f in ${helm_value_files[@]}; do
        cmd+=" -f ${f}";
    done
    cmd+=" $helm_release"
    cmd+=" --namespace $namespace"
    cmd+=" $chart"
    echo $cmd
}

run_helm_forall_charts() {
    run_cmd=$1
    shift
    local base_cmd=${@}
    for ch in ${helm_charts//,/ }; do
        local chart=${ch//@*}
        if [[ $ch == $chart ]]; then
            local helm_cmd=$(calc_helm_command $chart ${base_cmd})
            used_files+=" $ch"
            $run_cmd "$helm_cmd"
        else
            local helm_cmd=$(calc_helm_command $chart $base_cmd})
            local repo=${ch//*@}
            $run_cmd "$helm_cmd --repo $repo --version $chart_version"
        fi
    done
}

run_action_helm-install() {
    : ${helm_atomic_wait:=--wait --atomic --timeout 4m}
    local default_cmd="helm upgrade --install ${helm_atomic_wait} --create-namespace"
    run_helm_forall_charts "verbose_cmd" ${helm_install_command:-$default_cmd}
}

render_helm() {
    local default_cmd="helm template"
    local f
    used_files+=" ${helm_value_files[@]}"
    run_helm_forall_charts "verbose_pipe split_into_files" ${helm_template_command:-$default_cmd}
}

update_version_helm() {
    local res
    local val_file=($karmah_dir/values*.yaml)
    for res in $(calc_resource_names); do
        verbose updating $res version to $update_version
        verbose_cmd yq -i "${helm_update_version_path[$res]}=\"$update_version\"" $val_file
    done
}

update_replicas_helm() {
    local res
    local val_file=($karmah_dir/values*.yaml)
    for res in $(calc_resource_names); do
        local repl=${kube_replicas:-default}
        if [[ $repl == default ]]; then
            repl=${kube_default_replicas[$res]}
        fi
        verbose updating $res replicas to $repl
        verbose_cmd yq -i "${helm_update_replicas_path[$res]}=\"$repl\"" $val_file
    done
}

#####################################
# help.bash

init_bash_module_help() {
    add_command aliases "show all defined aliases"
    add_command version "show version of karmah"
    add_option h help "" "show help information"
}

parse_option_help() { show_help; exit; }

show_help() {
cat <<EOF
karmah: Kubernetes Application Rendered MAnifest Helper (version $karmah_version)

Description:
  karmah helps to enforce the rendered manifest pattern for targets
  Each target is defined in a karmah file, which defines various options, like:
  - rendering method to use (e.g. helm, kustomize)
  - rendering parameters, e.g. helm charts and value file
  - deployment method, e.g helm intstall, kapp deploy, kubectl apply
  - kubernetes info, e.g. kubeconfig, context and namespace
  - helper info, e.g. how to inspect, scale and change versions

Usage:
  karmah [ option | action | target ]...

EOF
show_short_help
cat <<EOF
Targets:
  Each path defines an application definition, that will be sourced,
  This can either be a file, or a directory that contains exactly 1 file with a name '*.karmah'.
  When one or more --subdirs are specfied, these will be append to the path

Note:
  If multiple commands are given, only last command will be used
EOF
}

show_short_help() {
echo Options:
for h in "${option_help[@]}"; do printf "%s\n" "$h"; done

echo Actions:
for h in "${action_help[@]}"; do printf "%s\n" "$h"; done
}


run_command_aliases() {
  echo Aliases:
  for key in $(printf "%s\n" ${!aliases[@]} | sort); do
      printf "  %-13s %s\n" $key "${aliases[$key]}"
  done |sort -k2 -k1
}

show_help_version() {
  echo karmah version: $karmah_version
}

#####################################
# kapp.bash

init_bash_module_kapp() {
    add_action kapp-plan "show what resources will be updated"
    add_action kapp-diff "show what resources will be updated, including detailed diffs"
    add_action kapp-deploy "deploy the application with kapp"
}

kapp_options() {
    local cl=${kube_cluster}
    local cfg=${kube_config_map[$cl]:-default}
    local opt=""
    if [[ $cfg != default ]]; then
        opt="--kube_config_map $cfg " # extra space at end
    fi
    opt+=" $yes_arg --kube_config_map-context ${kube_context_map[$cl]} -n ${namespace} -a $(basename $target) -f ${output_dir}"
    echo $opt
}

run_action_kapp-diff() {
    run_action_render
    verbose_cmd kapp deploy $(kapp_options) --diff-run --diff-changes
}

run_action_kapp-plan() {
    run_action_render
    verbose_cmd kapp deploy $(kapp_options) --diff-run
}

run_action_kapp-deploy() {
    run_action_render
    if ! kubectl $(kubectl_options) get ns $namespace >/dev/null 2>&1; then
        verbose_cmd kubectl $(kubectl_options) create ns $namespace
    fi
    verbose_cmd kapp deploy $(kapp_options)
}

#####################################
# karmah-version.bash
karmah_version=0.9x

#####################################
# kube.bash

init_bash_module_kube() {
    use_module render
    declare -Ag kube_config_map
    declare -Ag kube_context_map
    #declare -g kube_resource_list
    add_action kube-get "get current manifests from cluster to --to <path> (default) deployed/manifests"
    add_action kube-apply "apply rendered manifests with cluster (kubectl apply)"
    add_action kube-diff "compare rendered manifests with cluster (kubectl diff)"
    add_action kube-tmp-scale "scale resource(s) without changing source or deployment files"
    add_action kube-restart "restart resource(s)"
    add_action kubectl --collect "generic kubectl in the right cluster and namespace of all targets"
    add_option R replicas nr  "specify number of replicas"
    global_vars+=" kube_cluster namespace"
    global_arrays+=" kube_resource_alias kube_default_replicas"
}

parse_option_resource()  { kube_resource_list+=" $2"; parse_result=2; }
parse_option_replicas()  { kube_replicas="$2";  parse_result=2; }


kubectl_options() {
    local cl=${kube_cluster}
    local cfg=${kube_config_map[$cl]:-default}
    local opt=""
    if [[ $cfg != default ]]; then
        opt="--kube_config_map $cfg " # extra space at end
    fi
    opt+="--context ${kube_context_map[$cl]} -n $namespace"
    echo $opt
}

filter-kube-diff-output() { grep -E '^[+-] |^---'; }
run_action_kube-diff() {
    run_action_render
    info kube-diff ${target} to ${output_dir}
    if $(log_is_verbose); then
        verbose_cmd kubectl diff $(kubectl_options) -f $output_dir || true
    else
        verbose_pipe filter-kube-diff-output kubectl diff $(kubectl_options) -f $output_dir || true
    fi
}

run_action_kube-apply() {
    run_action_kube-diff
    info kube apply $output_dir
    verbose_cmd kubectl apply $(kubectl_options) -f $output_dir
}

run_action_kubectl() {
    info kubectl $output_dir
    verbose_cmd kubectl $(kubectl_options) $extra_args
}


split_kubectl_output_into_files() {
    yq  '.items.[]' -s \"$output_dir/\"'+ (.kind | downcase) + "_" + .metadata.name + ".yaml"'
}

run_action_kube-get-manifests() {
    info kube get manifests  ${target} to ${output_dir}
    verbose_cmd rm -rf ${output_dir}
    verbose_cmd mkdir -p ${output_dir}
    verbose_pipe split_kubectl_output_into_files kubectl ${kubectl_options[$kube_cluster]} -n "${namespace}" get deploy,svc,sts,cm,ingress -o yaml
    ignore_files=configmap_kube-root-ca.crt.yaml
    ignore_files+=" deployment_ingress-nginx-controller.yaml"
    ignore_files+=" service_ingress-nginx-controller-admission.yaml"
    ignore_files+=" service_ingress-nginx-controller.yaml"
    for f in ${ignore_files}; do
        rm -f "${output_dir}/$f"
    done
    for f in "${output_dir}"/*.yaml; do
         yq -i 'del(.metadata.annotations.["kubectl.kubernetes.io/last-applied-configuration"])' "${f}"
         yq -i 'del(.metadata.uid)' "${f}"
         yq -i 'del(.metadata.resourceVersion)' "${f}"
         yq -i 'del(.metadata.creationTimestamp)' "${f}"
    done
}

run_action_kube-get() {
    verbose_cmd kubectl $(kubectl_options) -n $namespace get ${extra_args:-pods,deploy,sts,cm}
}
run_action_kube-watch() {
    verbose_cmd watch kubectl $(kubectl_options) -n $namespace get ${extra_args:-pods,deploy,sts,cm}
}
run_action_kube-restart() {
    local res
    for res in ${kube_resource_list//,/ }; do
        res=${kube_resource_alias[$res]:-$res}
        verbose_cmd kubectl $(kubectl_options) -n $namespace rollout restart $res
    done
}
run_action_kube-tmp-scale() {
    local res
    for res in $(calc_resource_names); do
        verbose_cmd kubectl $(kubectl_options) -n $namespace scale $res --replicas $(calc_kube_replicas $res)
    done
}

calc_resource_names() {
    local result=${kube_resource_list:-all}
    if [[ $result == all ]]; then
        result=${all_resources}
    fi
    echo ${result//,/ }
}

calc_kube_replicas() {
    local repl=${kube_replicas:-default}
    if [[  $repl == default ]]; then
        repl=${kube_default_replicas[$1]}
    fi
    echo $repl
}

#####################################
# kustomize.bash

render_kustomize() {
    local command="kubectl kustomize --enable-helm"
    #used_files+=" $helm_chart_dir/$ch"
    verbose_pipe split_into_files "$command ${karmah_dir}"
}

#####################################
# render.bash

init_bash_module_render() {
    add_action render "render manifests to --to <path> (default tmp/manifests)"
    add_action compare "render manifests to --to <path> (default tmp/manifests) and then compare with --with path (default deployed/manifests)"
    global_vars+=" renderer output_dir"
    declare -g to_dir
    add_option s subdir   dir   "add subdir to list of subdirs (can be comma separated list)"
    add_option t to       path  "other path to render to (default is tmp/manifests)"
    add_option w with     path  used for comparison between two manifest trees
}

parse_option_subdir()    { subdirs+=" $2"; parse_result=2; }
parse_option_to()        { to_dir="$2"; parse_result=2; }
parse_option_with()      { with_dir="$2"; parse_result=2; }


run_action_render() {
    run_action_update
    info rendering ${target} with ${renderer} to ${output_dir}
    verbose_cmd rm -rf ${output_dir}
    verbose_cmd mkdir -p ${output_dir}
    for r in ${renderer//,/ }; do
        render_$r
    done
 }

run_action_compare() {
    run_action_render
    olddir=${output_dir}
    local newdir=${with_dir:-deployed/manifests}/${target}
    info comparing ${target}: ${output_dir} with ${newdir}
    verbose_cmd diff -r $newdir $olddir || true
}

split_into_files() {
    yq -P 'sort_keys(..)' | yq -s \"$output_dir/\"'+ (.kind | downcase) + "_" + .metadata.name + ".yaml"'
    rm -f ${output_dir}/_.yaml
}

#####################################
# update.bash

init_bash_module_update() {
    add_action update "update source files with expressions from --update"
    add_option V version ver  "specify version (tag) to use for update or scale"

    global_vars+=" update_version_function update_replicas_function"
    aliases[tmp-stop]="--action kube-tmp-scale --replicas 0"
    aliases[tmp-start]="--action kube-tmp-scale --replicas default"
    aliases[stop]="--action deploy --replicas 0"
    aliases[start]="--action deploy --replicas default"
}

parse_option_version()   { update_version="$2"; parse_result=2; }


run_action_update() {
    local any_updates=false
    if [[ ! -z ${update_version:-} ]]; then
        #info update $target version to $update_version
        ${update_version_function:-default_update_version}
        any_updates=true
    fi
    if [[ ! -z ${kube_replicas:-} ]]; then
        #info update $target replicas to $kube_replicas
        ${update_replicas_function:-default_update_replicas}
        any_updates=true
    fi
    $any_updates || verbose no updates detected
}

default_update_version() {
    local r
    local any_updates=false
    for r in ${renderer//,/ }; do
        if [[ $(type -t update_version_$r) == function ]]; then
            info updating $target version in $r to $update_version
            update_version_$r
            any_updates=true
        else
            debug skipping update version $r
        fi
    done
    $any_updates || warn no updates performed for version to $update_version
}

default_update_replicas() {
    local r
    local any_updates=false
    for r in ${renderer//,/ }; do
        if [[ $(type -t update_replicas_$r) == function ]]; then
            info updating $target replicas in $r to $kube_replicas
            update_replicas_$r
            any_updates=true
        else
            debug skipping update replicas $r
        fi
    done
    $any_updates || warn no updates performed for replicas to $kube_replicas
}

#####################################
# actions.bash
# run actions for all targets

init_bash_module_actions() {
    add_command "forall" "run actions for all targets"
    add_action ask "ask for confirmation (unless --yes is specified)"
    add_action deploy "render to deployed/manifests and optionally deploy to kubernetes"
    add_option a action act  add action to list of actions to perform
    add_option y yes    ""   do not ask for confirmatopm

    command=run_command_forall
    declare -g global_vars="karmah_type target"
    declare -g global_arrays=""
    yes_arg=""
}

parse_option_action() { action_list+=" $2"; parse_result=2; }
parse_option_yes()    { yes_arg="--yes"; }

run_action_ask() {
    if [[  $yes_arg == --yes ]]; then
        verbose skipping ask, because --yes is specified
        return 0
    fi
    local answer
    read -p "do you want to continue [y/N]? " answer
    if [[ "${answer}" != y ]] ;then
        info "Stopping karmah"
        exit 1
    fi
}


run_command_forall() {
    for path in $karmah_paths; do
        if [[ -f $path ]]; then
            karmah_file=$path
            run_karmah_file
        elif [[ -z ${subdirs:-} ]]; then
            karmah_file=($path/*.karmah) # use array for globbing
            run_karmah_file
        else
            for sd in ${subdirs//,/ }; do
                karmah_file=($path/$sd/*.karmah)  # use array for globbing
                run_karmah_file
            done
        fi
    done
}

init_karmah_type_basic() {
    verbose using empty karmah_type initializer
}

run_karmah_file() {
    local karmah_type
    if [[ -f "${karmah_file}" ]]; then
        # cleanup of any vars that might have been set with previous file
        debug clearing $global_vars $global_arrays
        unset $global_vars $global_arrays
        declare -g $global_vars
        declare -gA $global_arrays
        verbose loading ${karmah_file}
        local karmah_dir=$(dirname $karmah_file)
        local common_dir=$(dirname $karmah_dir)/common
        local used_files=${karmah_dir}
        local common_karmnah_file=($common_dir/common*.karmah)
        if [[ -f $common_karmnah_file ]]; then
            source $common_karmnah_file
        fi
        source ${karmah_file}
        init_karmah_type_${karmah_type:-basic}
        output_dir="${to_dir:-tmp/manifests}/${target}"
        run_actions ${action_list:-render}
    else
        info skipping $karmah_file
    fi
}

run_action_deploy() {
    output_dir="${to_dir:-deployed/manifests}/${target}"
    local actions=${deploy_actions:-render,git-diff,ask,git-commit}
    info deploying ${output_dir} with actions: ${actions}
    # TODO: output_dir is different for actions before this action
    run_actions $actions
}

run_actions() {
    for action in ${@//,/ }; do
        verbose running $action for ${target}
        run_action_$action;
    done
}

#####################################
main "${@}"
main "${@}"

#####################################
# pre.bash

#####################################
# argparse.bash

init_argparse() {
    declare -gA aliases=()
    declare -ga parsed_args=()

    declare -g karmah_paths=""
    declare -g subdirs=""
    declare -ga updates=()
    declare -ga action_help=()
    declare -ga command_help=()
    declare -ga option_help=()

    declare -gA parse_arg_func=()
    declare -g action_list=""
    declare -g command
}

add_option() {
    local short=$1
    local name=$2
    local arg=$3
    shift 3
    local help=$@
    parse_arg_func[--$name]=parse_option_$name
    if [[ -z $short ]]; then
        name="--$name"
    else
        parse_arg_func[-$short]=parse_option_$name
        name="-$short|--$name"
    fi
    [[ -z $arg ]] || name+=" <$arg>"
    option_help+=("$(printf "  %-20s %s\n" "$name" "$help")")
}

parse_set_command() { command=run_command_$1; }
add_command() {
    local name=$1
    shift 1
    local help=$@
    parse_arg_func[$name]=parse_set_command
    command_help+=("$(printf "  %-13s %s\n" "$name" "$help")")
}

parse_append_action() { action_list+=$1;  }
parse_append_action_with_args() { action_list+=$1; collect_unknown_args=true; }
add_action() {
    local name=$1
    shift 1
    if [[ ${1:-} == --collect ]]; then
        shift
        parse_arg_func[$name]=parse_append_action_with_args
    else
        parse_arg_func[$name]=parse_append_action
    fi
    local help="$@"
    action_help+=("$(printf "  %-13s %s\n" "$name" "$help")")
}

parse_arg() {
    local name=$1
    local func=${parse_arg_func[$name]:-}
    if [[ ! -z $func ]]; then
        parse_result=1
        $func "$@"
    fi
}


replace_aliases() {
    for arg in "${@}"; do
        local al="${aliases[$arg]:-none}"
        if [[ "$al" != none ]]; then
            replaced=true
            parsed_args+=($al)
        else
            parsed_args+=("$arg")
        fi
    done
}

parse_options() {
    local replaced=false
    local collect_unknown_args=false
    declare -g extra_args=""
    replace_aliases "${@}"
    set -- "${parsed_args[@]}"
    log_level=$log_level_info
    while [[ $# > 0 ]]; do
        arg=$1
        parse_result=0
        parse_arg "$@";
        if [[ $arg = -vv ]]; then # TODO: parse multiple short options
            log_level+=20;
        elif [[ "$parse_result" > 0 ]]; then
            shift $(( "$parse_result" - 1))
        else
            if [[ -f ${arg} ]]; then karmah_paths+=" ${arg}"
            elif [[ -d ${arg} ]]; then karmah_paths+=" ${arg%%/}" # remove a trailing /
            elif $collect_unknown_args; then extra_args+=" $arg"
            else
                echo unknown argument ${arg}, should be an option, action or path
                show_short_help
                exit 1
            fi
        fi
        shift
    done
    verbose COMMAND $(basename $0) ${parsed_args[@]}
}

#####################################
# config.bash

read_config() {
    : ${RENDER_CONFIG_FILE:=~/.config/karmah/config}
    if [[ -f ${RENDER_CONFIG_FILE} ]]; then
        source ${RENDER_CONFIG_FILE}
    fi
    if [[ -d config.d ]] && "${use_config_d:-true}"; then
        for inc in config.d/*.config; do
            source $inc
        done
    fi
    default_renderer=${RENDER_DEFAULT_RENDERER:-helm}
}

#####################################
# logging.bash

init_logging() {
    declare -gi log_level_fatal=0
    declare -gi log_level_error=10
    declare -gi log_level_warn=20
    declare -gi log_level_info=30
    declare -gi log_level_verbose=40
    declare -gi log_level_debug=50
    declare -gi log_level=$log_level_info
    declare -g  log_commands=false
    parse_loglevel "$@"
}

init_bash_module_logging() {
    use_module help
    add_option v verbose  ""    give more output
    add_option C show-cmd ""    show the commands being executed
    add_option q quiet    ""    show no output
    add_option n dry-run  ""    do not execute the actual commands
    add_option "" debug   ""    show detailded debug info
    aliases[plan]="--quiet --dry-run --show-cmd"
}

# TODO -vv
parse_option_verbose()   { log_level+=10; }
parse_option_quiet()     { log_level=$log_level_warn; }
parse_option_show-cmd()  { log_commands=true; }
parse_option_dry-run()   { dry_run=true; }
parse_option_debug()     { set -x; }


log_is_error()   { (( ${log_level} >= ${log_level_error} )) }
log_is_warn()    { (( ${log_level} >= ${log_level_warn} )) }
log_is_info()    { (( ${log_level} >= ${log_level_info} )) }
log_is_verbose() { (( ${log_level:-30} >= ${log_level_verbose:-40} )) }
log_is_debug()   { (( ${log_level} >= ${log_level_debug} )) }

error()   { if $(log_is_error) ;   then printf "ERROR "; printf "%s " "${@}"; echo; fi }
warn()    { if $(log_is_warn) ;    then printf "WARN "; printf "%s " "${@}"; echo; fi }
info()    { if $(log_is_info) ;    then printf "# ";  printf "%s " "${@}"; echo; fi }
verbose() { if $(log_is_verbose) ; then printf "## "; printf "%s " "${@}"; echo; fi }
debug()   { if $(log_is_debug) ;   then printf "### ";  printf "%s " "${@}"; echo; fi }

verbose_cmd() {
    if (( $log_level >= $log_level_verbose )); then
        printf "    "; echo "${@}";
    elif $log_commands; then
        printf "    "; echo "${@}";
    fi
    if ! ${dry_run:-false}; then
        cmd=$1; shift
        $cmd "${@}"
    fi
}

verbose_pipe() {
    pipe=$1
    shift
    if (( $log_level >= $log_level_verbose )); then
        printf "    "; echo "${@}" \| $pipe;
    elif $log_commands; then
        printf "    "; echo "${@}" \| $pipe;
    fi
    if ! ${dry_run:-false}; then
        cmd=$1; shift
        $cmd "${@}" | $pipe
    fi
}


parse_loglevel() {
    for arg in "$@"; do
        if [[ $arg == -v ]]; then log_level+=10; fi
    done
}

#####################################
# module.bash

load_module() {
    file="$1"
    shift
    if [[ ${module_files["${file}"]:-} == loaded ]]; then
        verbose skipping module file "${file}" already loaded
        return 0
    fi
    module_files["${file}"]=loaded
    local filename="$(basename "${file}")"
    local module="${filename%%.lib}"
    verbose loading module "${module}" from "${file}"
    source "${file}"
}

use_module() {
    local module="$1"
    if ${module_needs_init["${module}"]:-true}; then
        debug running init module for "${module}"
        init_bash_module_${module}
        module_needs_init["${module}"]=false
    fi
}

init_all_modules() {
    declare -g modules=""
    declare -gA module_needs_init=()
    declare -gA module_files=()
    use_module logging
    modules=$(set | grep '^init_bash_module_'| sed -e 's/init_bash_module_//' -e 's/ *()//')
    for m in $modules; do
        use_module $m
    done
}

#####################################
# copy-files.bash

render_copy-files() {
    files_list="$karmah_dir"/files/*.yaml
    verbose_cmd cp -f ${files_list} ${output_dir}
}

#####################################
# git.bash

init_bash_module_git() {
    use_module render
    declare -g used_files=""
    declare -g git_pulled=false
    add_action git-diff "shows the changes to source and rendered manifests with git"
    add_action git-add "adds the changes to source and rendered manifests to git, for committing"
    add_action git-commit "commits the changes to source and rendered manifests to git"

    add_option m message  msg   set message to us with git commit
    global_vars+=" used_files"  # TODO: git_commit_message
}

parse_option_message()   { git_commit_message="$2";   parse_result=2; }

run_action_git-pull() {
    verbose_cmd git pull
}

run_action_git-diff() {
    info git-diff ${target} to ${output_dir}
    if $(log_is_verbose); then
        verbose_cmd git diff -- ${used_files} ${output_dir} || true
    else
        verbose_cmd git diff -- ${used_files} ${output_dir} | grep -E '^[+-]|^---' || true
    fi
}

run_action_git-add() {
    info git-add ${target} to ${output_dir}
    verbose_cmd git add ${used_files} ${output_dir}
}

run_action_git-status() {
    git status
}


run_action_git-commit() {
    run_action_git-add
    : ${git_commit_message:=${action} of ${target}}
    verbose_cmd git commit -m "${git_commit_message}" ${used_files} ${output_dir}
}

#####################################
# helm.bash

init_bash_module_helm() {
    use_module render
    add_action helm-install "run helm-install"
    global_vars+=" helm_template_command helm_value_files helm_charts helm_install_command helm_atomic_wait"
    global_arrays+="helm_update_version_path helm_update_replicas_path"
}

add_optional_helm_values_file() {
    local f=($1)
    if [[ -f $f ]]; then
        debug adding values file $f
        helm_value_files+=("$f")
    else
        debug skipping values file $f
    fi
}

init_helm_vars() {
    local parent_dir=$(dirname "$karmah_dir")
    add_optional_helm_values_file "$common_dir/values*.yaml"
    add_optional_helm_values_file "$karmah_dir/values*.yaml"
}

calc_helm_command() {
    local chart=$1
    shift
    local cmd=$@
    local f
    local helm_release=$(basename $target)
    for f in ${helm_value_files[@]}; do
        cmd+=" -f ${f}";
    done
    cmd+=" $helm_release"
    cmd+=" --namespace $namespace"
    cmd+=" $chart"
    echo $cmd
}

run_helm_forall_charts() {
    run_cmd=$1
    shift
    local base_cmd=${@}
    for ch in ${helm_charts//,/ }; do
        local chart=${ch//@*}
        if [[ $ch == $chart ]]; then
            local helm_cmd=$(calc_helm_command $chart ${base_cmd})
            used_files+=" $ch"
            $run_cmd "$helm_cmd"
        else
            local helm_cmd=$(calc_helm_command $chart $base_cmd})
            local repo=${ch//*@}
            $run_cmd "$helm_cmd --repo $repo --version $chart_version"
        fi
    done
}

run_action_helm-install() {
    : ${helm_atomic_wait:=--wait --atomic --timeout 4m}
    local default_cmd="helm upgrade --install ${helm_atomic_wait} --create-namespace"
    run_helm_forall_charts "verbose_cmd" ${helm_install_command:-$default_cmd}
}

render_helm() {
    local default_cmd="helm template"
    local f
    used_files+=" ${helm_value_files[@]}"
    run_helm_forall_charts "verbose_pipe split_into_files" ${helm_template_command:-$default_cmd}
}

update_version_helm() {
    local res
    local val_file=($karmah_dir/values*.yaml)
    for res in $(calc_resource_names); do
        verbose updating $res version to $update_version
        verbose_cmd yq -i "${helm_update_version_path[$res]}=\"$update_version\"" $val_file
    done
}

update_replicas_helm() {
    local res
    local val_file=($karmah_dir/values*.yaml)
    for res in $(calc_resource_names); do
        local repl=${kube_replicas:-default}
        if [[ $repl == default ]]; then
            repl=${kube_default_replicas[$res]}
        fi
        verbose updating $res replicas to $repl
        verbose_cmd yq -i "${helm_update_replicas_path[$res]}=\"$repl\"" $val_file
    done
}

#####################################
# help.bash

init_bash_module_help() {
    add_command aliases "show all defined aliases"
    add_command version "show version of karmah"
    add_option h help "" "show help information"
}

parse_option_help() { show_help; exit; }

show_help() {
cat <<EOF
karmah: Kubernetes Application Rendered MAnifest Helper (version $karmah_version)

Description:
  karmah helps to enforce the rendered manifest pattern for targets
  Each target is defined in a karmah file, which defines various options, like:
  - rendering method to use (e.g. helm, kustomize)
  - rendering parameters, e.g. helm charts and value file
  - deployment method, e.g helm intstall, kapp deploy, kubectl apply
  - kubernetes info, e.g. kubeconfig, context and namespace
  - helper info, e.g. how to inspect, scale and change versions

Usage:
  karmah [ option | action | target ]...

EOF
show_short_help
cat <<EOF
Targets:
  Each path defines an application definition, that will be sourced,
  This can either be a file, or a directory that contains exactly 1 file with a name '*.karmah'.
  When one or more --subdirs are specfied, these will be append to the path

Note:
  If multiple commands are given, only last command will be used
EOF
}

show_short_help() {
echo Options:
for h in "${option_help[@]}"; do printf "%s\n" "$h"; done

echo Actions:
for h in "${action_help[@]}"; do printf "%s\n" "$h"; done
}


run_command_aliases() {
  echo Aliases:
  for key in $(printf "%s\n" ${!aliases[@]} | sort); do
      printf "  %-13s %s\n" $key "${aliases[$key]}"
  done |sort -k2 -k1
}

show_help_version() {
  echo karmah version: $karmah_version
}

#####################################
# kapp.bash

init_bash_module_kapp() {
    add_action kapp-plan "show what resources will be updated"
    add_action kapp-diff "show what resources will be updated, including detailed diffs"
    add_action kapp-deploy "deploy the application with kapp"
}

kapp_options() {
    local cl=${kube_cluster}
    local cfg=${kube_config_map[$cl]:-default}
    local opt=""
    if [[ $cfg != default ]]; then
        opt="--kube_config_map $cfg " # extra space at end
    fi
    opt+=" $yes_arg --kube_config_map-context ${kube_context_map[$cl]} -n ${namespace} -a $(basename $target) -f ${output_dir}"
    echo $opt
}

run_action_kapp-diff() {
    run_action_render
    verbose_cmd kapp deploy $(kapp_options) --diff-run --diff-changes
}

run_action_kapp-plan() {
    run_action_render
    verbose_cmd kapp deploy $(kapp_options) --diff-run
}

run_action_kapp-deploy() {
    run_action_render
    if ! kubectl $(kubectl_options) get ns $namespace >/dev/null 2>&1; then
        verbose_cmd kubectl $(kubectl_options) create ns $namespace
    fi
    verbose_cmd kapp deploy $(kapp_options)
}

#####################################
# karmah-version.bash
karmah_version=0.9x

#####################################
# kube.bash

init_bash_module_kube() {
    use_module render
    declare -Ag kube_config_map
    declare -Ag kube_context_map
    #declare -g kube_resource_list
    add_action kube-get "get current manifests from cluster to --to <path> (default) deployed/manifests"
    add_action kube-apply "apply rendered manifests with cluster (kubectl apply)"
    add_action kube-diff "compare rendered manifests with cluster (kubectl diff)"
    add_action kube-tmp-scale "scale resource(s) without changing source or deployment files"
    add_action kube-restart "restart resource(s)"
    add_action kubectl --collect "generic kubectl in the right cluster and namespace of all targets"
    add_option R replicas nr  "specify number of replicas"
    global_vars+=" kube_cluster namespace"
    global_arrays+=" kube_resource_alias kube_default_replicas"
}

parse_option_resource()  { kube_resource_list+=" $2"; parse_result=2; }
parse_option_replicas()  { kube_replicas="$2";  parse_result=2; }


kubectl_options() {
    local cl=${kube_cluster}
    local cfg=${kube_config_map[$cl]:-default}
    local opt=""
    if [[ $cfg != default ]]; then
        opt="--kube_config_map $cfg " # extra space at end
    fi
    opt+="--context ${kube_context_map[$cl]} -n $namespace"
    echo $opt
}

filter-kube-diff-output() { grep -E '^[+-] |^---'; }
run_action_kube-diff() {
    run_action_render
    info kube-diff ${target} to ${output_dir}
    if $(log_is_verbose); then
        verbose_cmd kubectl diff $(kubectl_options) -f $output_dir || true
    else
        verbose_pipe filter-kube-diff-output kubectl diff $(kubectl_options) -f $output_dir || true
    fi
}

run_action_kube-apply() {
    run_action_kube-diff
    info kube apply $output_dir
    verbose_cmd kubectl apply $(kubectl_options) -f $output_dir
}

run_action_kubectl() {
    info kubectl $output_dir
    verbose_cmd kubectl $(kubectl_options) $extra_args
}


split_kubectl_output_into_files() {
    yq  '.items.[]' -s \"$output_dir/\"'+ (.kind | downcase) + "_" + .metadata.name + ".yaml"'
}

run_action_kube-get-manifests() {
    info kube get manifests  ${target} to ${output_dir}
    verbose_cmd rm -rf ${output_dir}
    verbose_cmd mkdir -p ${output_dir}
    verbose_pipe split_kubectl_output_into_files kubectl ${kubectl_options[$kube_cluster]} -n "${namespace}" get deploy,svc,sts,cm,ingress -o yaml
    ignore_files=configmap_kube-root-ca.crt.yaml
    ignore_files+=" deployment_ingress-nginx-controller.yaml"
    ignore_files+=" service_ingress-nginx-controller-admission.yaml"
    ignore_files+=" service_ingress-nginx-controller.yaml"
    for f in ${ignore_files}; do
        rm -f "${output_dir}/$f"
    done
    for f in "${output_dir}"/*.yaml; do
         yq -i 'del(.metadata.annotations.["kubectl.kubernetes.io/last-applied-configuration"])' "${f}"
         yq -i 'del(.metadata.uid)' "${f}"
         yq -i 'del(.metadata.resourceVersion)' "${f}"
         yq -i 'del(.metadata.creationTimestamp)' "${f}"
    done
}

run_action_kube-get() {
    verbose_cmd kubectl $(kubectl_options) -n $namespace get ${extra_args:-pods,deploy,sts,cm}
}
run_action_kube-watch() {
    verbose_cmd watch kubectl $(kubectl_options) -n $namespace get ${extra_args:-pods,deploy,sts,cm}
}
run_action_kube-restart() {
    local res
    for res in ${kube_resource_list//,/ }; do
        res=${kube_resource_alias[$res]:-$res}
        verbose_cmd kubectl $(kubectl_options) -n $namespace rollout restart $res
    done
}
run_action_kube-tmp-scale() {
    local res
    for res in $(calc_resource_names); do
        verbose_cmd kubectl $(kubectl_options) -n $namespace scale $res --replicas $(calc_kube_replicas $res)
    done
}

calc_resource_names() {
    local result=${kube_resource_list:-all}
    if [[ $result == all ]]; then
        result=${all_resources}
    fi
    echo ${result//,/ }
}

calc_kube_replicas() {
    local repl=${kube_replicas:-default}
    if [[  $repl == default ]]; then
        repl=${kube_default_replicas[$1]}
    fi
    echo $repl
}

#####################################
# kustomize.bash

render_kustomize() {
    local command="kubectl kustomize --enable-helm"
    #used_files+=" $helm_chart_dir/$ch"
    verbose_pipe split_into_files "$command ${karmah_dir}"
}

#####################################
# render.bash

init_bash_module_render() {
    add_action render "render manifests to --to <path> (default tmp/manifests)"
    add_action compare "render manifests to --to <path> (default tmp/manifests) and then compare with --with path (default deployed/manifests)"
    global_vars+=" renderer output_dir"
    declare -g to_dir
    add_option s subdir   dir   "add subdir to list of subdirs (can be comma separated list)"
    add_option t to       path  "other path to render to (default is tmp/manifests)"
    add_option w with     path  used for comparison between two manifest trees
}

parse_option_subdir()    { subdirs+=" $2"; parse_result=2; }
parse_option_to()        { to_dir="$2"; parse_result=2; }
parse_option_with()      { with_dir="$2"; parse_result=2; }


run_action_render() {
    run_action_update
    info rendering ${target} with ${renderer} to ${output_dir}
    verbose_cmd rm -rf ${output_dir}
    verbose_cmd mkdir -p ${output_dir}
    for r in ${renderer//,/ }; do
        render_$r
    done
 }

run_action_compare() {
    run_action_render
    olddir=${output_dir}
    local newdir=${with_dir:-deployed/manifests}/${target}
    info comparing ${target}: ${output_dir} with ${newdir}
    verbose_cmd diff -r $newdir $olddir || true
}

split_into_files() {
    yq -P 'sort_keys(..)' | yq -s \"$output_dir/\"'+ (.kind | downcase) + "_" + .metadata.name + ".yaml"'
    rm -f ${output_dir}/_.yaml
}

#####################################
# update.bash

init_bash_module_update() {
    add_action update "update source files with expressions from --update"
    add_option V version ver  "specify version (tag) to use for update or scale"

    global_vars+=" update_version_function update_replicas_function"
    aliases[tmp-stop]="--action kube-tmp-scale --replicas 0"
    aliases[tmp-start]="--action kube-tmp-scale --replicas default"
    aliases[stop]="--action deploy --replicas 0"
    aliases[start]="--action deploy --replicas default"
}

parse_option_version()   { update_version="$2"; parse_result=2; }


run_action_update() {
    local any_updates=false
    if [[ ! -z ${update_version:-} ]]; then
        #info update $target version to $update_version
        ${update_version_function:-default_update_version}
        any_updates=true
    fi
    if [[ ! -z ${kube_replicas:-} ]]; then
        #info update $target replicas to $kube_replicas
        ${update_replicas_function:-default_update_replicas}
        any_updates=true
    fi
    $any_updates || verbose no updates detected
}

default_update_version() {
    local r
    local any_updates=false
    for r in ${renderer//,/ }; do
        if [[ $(type -t update_version_$r) == function ]]; then
            info updating $target version in $r to $update_version
            update_version_$r
            any_updates=true
        else
            debug skipping update version $r
        fi
    done
    $any_updates || warn no updates performed for version to $update_version
}

default_update_replicas() {
    local r
    local any_updates=false
    for r in ${renderer//,/ }; do
        if [[ $(type -t update_replicas_$r) == function ]]; then
            info updating $target replicas in $r to $kube_replicas
            update_replicas_$r
            any_updates=true
        else
            debug skipping update replicas $r
        fi
    done
    $any_updates || warn no updates performed for replicas to $kube_replicas
}

#####################################
# actions.bash
# run actions for all targets

init_bash_module_actions() {
    add_command "forall" "run actions for all targets"
    add_action ask "ask for confirmation (unless --yes is specified)"
    add_action deploy "render to deployed/manifests and optionally deploy to kubernetes"
    add_option a action act  add action to list of actions to perform
    add_option y yes    ""   do not ask for confirmatopm

    command=run_command_forall
    declare -g global_vars="karmah_type target"
    declare -g global_arrays=""
    yes_arg=""
}

parse_option_action() { action_list+=" $2"; parse_result=2; }
parse_option_yes()    { yes_arg="--yes"; }

run_action_ask() {
    if [[  $yes_arg == --yes ]]; then
        verbose skipping ask, because --yes is specified
        return 0
    fi
    local answer
    read -p "do you want to continue [y/N]? " answer
    if [[ "${answer}" != y ]] ;then
        info "Stopping karmah"
        exit 1
    fi
}


run_command_forall() {
    for path in $karmah_paths; do
        if [[ -f $path ]]; then
            karmah_file=$path
            run_karmah_file
        elif [[ -z ${subdirs:-} ]]; then
            karmah_file=($path/*.karmah) # use array for globbing
            run_karmah_file
        else
            for sd in ${subdirs//,/ }; do
                karmah_file=($path/$sd/*.karmah)  # use array for globbing
                run_karmah_file
            done
        fi
    done
}

init_karmah_type_basic() {
    verbose using empty karmah_type initializer
}

run_karmah_file() {
    local karmah_type
    if [[ -f "${karmah_file}" ]]; then
        # cleanup of any vars that might have been set with previous file
        debug clearing $global_vars $global_arrays
        unset $global_vars $global_arrays
        declare -g $global_vars
        declare -gA $global_arrays
        verbose loading ${karmah_file}
        local karmah_dir=$(dirname $karmah_file)
        local common_dir=$(dirname $karmah_dir)/common
        local used_files=${karmah_dir}
        local common_karmnah_file=($common_dir/common*.karmah)
        if [[ -f $common_karmnah_file ]]; then
            source $common_karmnah_file
        fi
        source ${karmah_file}
        init_karmah_type_${karmah_type:-basic}
        output_dir="${to_dir:-tmp/manifests}/${target}"
        run_actions ${action_list:-render}
    else
        info skipping $karmah_file
    fi
}

run_action_deploy() {
    output_dir="${to_dir:-deployed/manifests}/${target}"
    local actions=${deploy_actions:-render,git-diff,ask,git-commit}
    info deploying ${output_dir} with actions: ${actions}
    # TODO: output_dir is different for actions before this action
    run_actions $actions
}

run_actions() {
    for action in ${@//,/ }; do
        verbose running $action for ${target}
        run_action_$action;
    done
}

#####################################
main "${@}"

#####################################
# pre.bash
#!/usr/bin/env bash
# Script Name: karmah
# Description: Kubernetes Assortment of Rendered MAnifests Helpers
# Author: Mark Hooijkaas
# Sourcecode: https://github.com/kisst-org/karmah/
# License: Apache License version 2.0
# Install or update to newest version with following command:
#   curl -OL https://raw.githubusercontent.com/kisst-org/karmah/refs/heads/main/karmah && chmod 755 karmah

set -eu
shopt -s extglob
script_name="${0}"

main() {
    init_argparse
    init_logging "${@}"
    init_all_modules
    read_config
    parse_options "${@}"
    $command
}

#####################################
# argparse.bash

init_argparse() {
    declare -gA aliases=()
    declare -ga parsed_args=()

    declare -g karmah_paths=""
    declare -g subdirs=""
    declare -ga updates=()
    declare -ga action_help=()
    declare -ga command_help=()
    declare -ga option_help=()

    declare -gA parse_arg_func=()
    declare -g action_list=""
    declare -g command
}

add_option() {
    local short=$1
    local name=$2
    local arg=$3
    shift 3
    local help=$@
    parse_arg_func[--$name]=parse_option_$name
    if [[ -z $short ]]; then
        name="--$name"
    else
        parse_arg_func[-$short]=parse_option_$name
        name="-$short|--$name"
    fi
    [[ -z $arg ]] || name+=" <$arg>"
    option_help+=("$(printf "  %-20s %s\n" "$name" "$help")")
}

parse_set_command() { command=run_command_$1; }
add_command() {
    local name=$1
    shift 1
    local help=$@
    parse_arg_func[$name]=parse_set_command
    command_help+=("$(printf "  %-13s %s\n" "$name" "$help")")
}

parse_append_action() { action_list+=$1;  }
parse_append_action_with_args() { action_list+=$1; collect_unknown_args=true; }
add_action() {
    local name=$1
    shift 1
    if [[ ${1:-} == --collect ]]; then
        shift
        parse_arg_func[$name]=parse_append_action_with_args
    else
        parse_arg_func[$name]=parse_append_action
    fi
    local help="$@"
    action_help+=("$(printf "  %-13s %s\n" "$name" "$help")")
}

parse_arg() {
    local name=$1
    local func=${parse_arg_func[$name]:-}
    if [[ ! -z $func ]]; then
        parse_result=1
        $func "$@"
    fi
}


replace_aliases() {
    for arg in "${@}"; do
        local al="${aliases[$arg]:-none}"
        if [[ "$al" != none ]]; then
            replaced=true
            parsed_args+=($al)
        else
            parsed_args+=("$arg")
        fi
    done
}

parse_options() {
    local replaced=false
    local collect_unknown_args=false
    declare -g extra_args=""
    replace_aliases "${@}"
    set -- "${parsed_args[@]}"
    log_level=$log_level_info
    while [[ $# > 0 ]]; do
        arg=$1
        parse_result=0
        parse_arg "$@";
        if [[ $arg = -vv ]]; then # TODO: parse multiple short options
            log_level+=20;
        elif [[ "$parse_result" > 0 ]]; then
            shift $(( "$parse_result" - 1))
        else
            if [[ -f ${arg} ]]; then karmah_paths+=" ${arg}"
            elif [[ -d ${arg} ]]; then karmah_paths+=" ${arg%%/}" # remove a trailing /
            elif $collect_unknown_args; then extra_args+=" $arg"
            else
                echo unknown argument ${arg}, should be an option, action or path
                show_short_help
                exit 1
            fi
        fi
        shift
    done
    verbose COMMAND $(basename $0) ${parsed_args[@]}
}

#####################################
# config.bash

read_config() {
    : ${RENDER_CONFIG_FILE:=~/.config/karmah/config}
    if [[ -f ${RENDER_CONFIG_FILE} ]]; then
        source ${RENDER_CONFIG_FILE}
    fi
    if [[ -d config.d ]] && "${use_config_d:-true}"; then
        for inc in config.d/*.config; do
            source $inc
        done
    fi
    default_renderer=${RENDER_DEFAULT_RENDERER:-helm}
}

#####################################
# logging.bash

init_logging() {
    declare -gi log_level_fatal=0
    declare -gi log_level_error=10
    declare -gi log_level_warn=20
    declare -gi log_level_info=30
    declare -gi log_level_verbose=40
    declare -gi log_level_debug=50
    declare -gi log_level=$log_level_info
    declare -g  log_commands=false
    parse_loglevel "$@"
}

init_bash_module_logging() {
    use_module help
    add_option v verbose  ""    give more output
    add_option C show-cmd ""    show the commands being executed
    add_option q quiet    ""    show no output
    add_option n dry-run  ""    do not execute the actual commands
    add_option "" debug   ""    show detailded debug info
    aliases[plan]="--quiet --dry-run --show-cmd"
}

# TODO -vv
parse_option_verbose()   { log_level+=10; }
parse_option_quiet()     { log_level=$log_level_warn; }
parse_option_show-cmd()  { log_commands=true; }
parse_option_dry-run()   { dry_run=true; }
parse_option_debug()     { set -x; }


log_is_error()   { (( ${log_level} >= ${log_level_error} )) }
log_is_warn()    { (( ${log_level} >= ${log_level_warn} )) }
log_is_info()    { (( ${log_level} >= ${log_level_info} )) }
log_is_verbose() { (( ${log_level:-30} >= ${log_level_verbose:-40} )) }
log_is_debug()   { (( ${log_level} >= ${log_level_debug} )) }

error()   { if $(log_is_error) ;   then printf "ERROR "; printf "%s " "${@}"; echo; fi }
warn()    { if $(log_is_warn) ;    then printf "WARN "; printf "%s " "${@}"; echo; fi }
info()    { if $(log_is_info) ;    then printf "# ";  printf "%s " "${@}"; echo; fi }
verbose() { if $(log_is_verbose) ; then printf "## "; printf "%s " "${@}"; echo; fi }
debug()   { if $(log_is_debug) ;   then printf "### ";  printf "%s " "${@}"; echo; fi }

verbose_cmd() {
    if (( $log_level >= $log_level_verbose )); then
        printf "    "; echo "${@}";
    elif $log_commands; then
        printf "    "; echo "${@}";
    fi
    if ! ${dry_run:-false}; then
        cmd=$1; shift
        $cmd "${@}"
    fi
}

verbose_pipe() {
    pipe=$1
    shift
    if (( $log_level >= $log_level_verbose )); then
        printf "    "; echo "${@}" \| $pipe;
    elif $log_commands; then
        printf "    "; echo "${@}" \| $pipe;
    fi
    if ! ${dry_run:-false}; then
        cmd=$1; shift
        $cmd "${@}" | $pipe
    fi
}


parse_loglevel() {
    for arg in "$@"; do
        if [[ $arg == -v ]]; then log_level+=10; fi
    done
}

#####################################
# module.bash

load_module() {
    file="$1"
    shift
    if [[ ${module_files["${file}"]:-} == loaded ]]; then
        verbose skipping module file "${file}" already loaded
        return 0
    fi
    module_files["${file}"]=loaded
    local filename="$(basename "${file}")"
    local module="${filename%%.lib}"
    verbose loading module "${module}" from "${file}"
    source "${file}"
}

use_module() {
    local module="$1"
    if ${module_needs_init["${module}"]:-true}; then
        debug running init module for "${module}"
        init_bash_module_${module}
        module_needs_init["${module}"]=false
    fi
}

init_all_modules() {
    declare -g modules=""
    declare -gA module_needs_init=()
    declare -gA module_files=()
    use_module logging
    modules=$(set | grep '^init_bash_module_'| sed -e 's/init_bash_module_//' -e 's/ *()//')
    for m in $modules; do
        use_module $m
    done
}

#####################################
# copy-files.bash

render_copy-files() {
    files_list="$karmah_dir"/files/*.yaml
    verbose_cmd cp -f ${files_list} ${output_dir}
}

#####################################
# git.bash

init_bash_module_git() {
    use_module render
    declare -g used_files=""
    declare -g git_pulled=false
    add_action git-diff "shows the changes to source and rendered manifests with git"
    add_action git-add "adds the changes to source and rendered manifests to git, for committing"
    add_action git-commit "commits the changes to source and rendered manifests to git"

    add_option m message  msg   set message to us with git commit
    global_vars+=" used_files"  # TODO: git_commit_message
}

parse_option_message()   { git_commit_message="$2";   parse_result=2; }

run_action_git-pull() {
    verbose_cmd git pull
}

run_action_git-diff() {
    info git-diff ${target} to ${output_dir}
    if $(log_is_verbose); then
        verbose_cmd git diff -- ${used_files} ${output_dir} || true
    else
        verbose_cmd git diff -- ${used_files} ${output_dir} | grep -E '^[+-]|^---' || true
    fi
}

run_action_git-add() {
    info git-add ${target} to ${output_dir}
    verbose_cmd git add ${used_files} ${output_dir}
}

run_action_git-status() {
    git status
}


run_action_git-commit() {
    run_action_git-add
    : ${git_commit_message:=${action} of ${target}}
    verbose_cmd git commit -m "${git_commit_message}" ${used_files} ${output_dir}
}

#####################################
# helm.bash

init_bash_module_helm() {
    use_module render
    add_action helm-install "run helm-install"
    global_vars+=" helm_template_command helm_value_files helm_charts helm_install_command helm_atomic_wait"
    global_arrays+="helm_update_version_path helm_update_replicas_path"
}

add_optional_helm_values_file() {
    local f=($1)
    if [[ -f $f ]]; then
        debug adding values file $f
        helm_value_files+=("$f")
    else
        debug skipping values file $f
    fi
}

init_helm_vars() {
    local parent_dir=$(dirname "$karmah_dir")
    add_optional_helm_values_file "$common_dir/values*.yaml"
    add_optional_helm_values_file "$karmah_dir/values*.yaml"
}

calc_helm_command() {
    local chart=$1
    shift
    local cmd=$@
    local f
    local helm_release=$(basename $target)
    for f in ${helm_value_files[@]}; do
        cmd+=" -f ${f}";
    done
    cmd+=" $helm_release"
    cmd+=" --namespace $namespace"
    cmd+=" $chart"
    echo $cmd
}

run_helm_forall_charts() {
    run_cmd=$1
    shift
    local base_cmd=${@}
    for ch in ${helm_charts//,/ }; do
        local chart=${ch//@*}
        if [[ $ch == $chart ]]; then
            local helm_cmd=$(calc_helm_command $chart ${base_cmd})
            used_files+=" $ch"
            $run_cmd "$helm_cmd"
        else
            local helm_cmd=$(calc_helm_command $chart $base_cmd})
            local repo=${ch//*@}
            $run_cmd "$helm_cmd --repo $repo --version $chart_version"
        fi
    done
}

run_action_helm-install() {
    : ${helm_atomic_wait:=--wait --atomic --timeout 4m}
    local default_cmd="helm upgrade --install ${helm_atomic_wait} --create-namespace"
    run_helm_forall_charts "verbose_cmd" ${helm_install_command:-$default_cmd}
}

render_helm() {
    local default_cmd="helm template"
    local f
    used_files+=" ${helm_value_files[@]}"
    run_helm_forall_charts "verbose_pipe split_into_files" ${helm_template_command:-$default_cmd}
}

update_version_helm() {
    local res
    local val_file=($karmah_dir/values*.yaml)
    for res in $(calc_resource_names); do
        verbose updating $res version to $update_version
        verbose_cmd yq -i "${helm_update_version_path[$res]}=\"$update_version\"" $val_file
    done
}

update_replicas_helm() {
    local res
    local val_file=($karmah_dir/values*.yaml)
    for res in $(calc_resource_names); do
        local repl=${kube_replicas:-default}
        if [[ $repl == default ]]; then
            repl=${kube_default_replicas[$res]}
        fi
        verbose updating $res replicas to $repl
        verbose_cmd yq -i "${helm_update_replicas_path[$res]}=\"$repl\"" $val_file
    done
}

#####################################
# help.bash

init_bash_module_help() {
    add_command aliases "show all defined aliases"
    add_command version "show version of karmah"
    add_option h help "" "show help information"
}

parse_option_help() { show_help; exit; }

show_help() {
cat <<EOF
karmah: Kubernetes Application Rendered MAnifest Helper (version $karmah_version)

Description:
  karmah helps to enforce the rendered manifest pattern for targets
  Each target is defined in a karmah file, which defines various options, like:
  - rendering method to use (e.g. helm, kustomize)
  - rendering parameters, e.g. helm charts and value file
  - deployment method, e.g helm intstall, kapp deploy, kubectl apply
  - kubernetes info, e.g. kubeconfig, context and namespace
  - helper info, e.g. how to inspect, scale and change versions

Usage:
  karmah [ option | action | target ]...

EOF
show_short_help
cat <<EOF
Targets:
  Each path defines an application definition, that will be sourced,
  This can either be a file, or a directory that contains exactly 1 file with a name '*.karmah'.
  When one or more --subdirs are specfied, these will be append to the path

Note:
  If multiple commands are given, only last command will be used
EOF
}

show_short_help() {
echo Options:
for h in "${option_help[@]}"; do printf "%s\n" "$h"; done

echo Actions:
for h in "${action_help[@]}"; do printf "%s\n" "$h"; done
}


run_command_aliases() {
  echo Aliases:
  for key in $(printf "%s\n" ${!aliases[@]} | sort); do
      printf "  %-13s %s\n" $key "${aliases[$key]}"
  done |sort -k2 -k1
}

show_help_version() {
  echo karmah version: $karmah_version
}

#####################################
# kapp.bash

init_bash_module_kapp() {
    add_action kapp-plan "show what resources will be updated"
    add_action kapp-diff "show what resources will be updated, including detailed diffs"
    add_action kapp-deploy "deploy the application with kapp"
}

kapp_options() {
    local cl=${kube_cluster}
    local cfg=${kube_config_map[$cl]:-default}
    local opt=""
    if [[ $cfg != default ]]; then
        opt="--kube_config_map $cfg " # extra space at end
    fi
    opt+=" $yes_arg --kube_config_map-context ${kube_context_map[$cl]} -n ${namespace} -a $(basename $target) -f ${output_dir}"
    echo $opt
}

run_action_kapp-diff() {
    run_action_render
    verbose_cmd kapp deploy $(kapp_options) --diff-run --diff-changes
}

run_action_kapp-plan() {
    run_action_render
    verbose_cmd kapp deploy $(kapp_options) --diff-run
}

run_action_kapp-deploy() {
    run_action_render
    if ! kubectl $(kubectl_options) get ns $namespace >/dev/null 2>&1; then
        verbose_cmd kubectl $(kubectl_options) create ns $namespace
    fi
    verbose_cmd kapp deploy $(kapp_options)
}

#####################################
# karmah-version.bash
karmah_version=0.9x

#####################################
# kube.bash

init_bash_module_kube() {
    use_module render
    declare -Ag kube_config_map
    declare -Ag kube_context_map
    #declare -g kube_resource_list
    add_action kube-get "get current manifests from cluster to --to <path> (default) deployed/manifests"
    add_action kube-apply "apply rendered manifests with cluster (kubectl apply)"
    add_action kube-diff "compare rendered manifests with cluster (kubectl diff)"
    add_action kube-tmp-scale "scale resource(s) without changing source or deployment files"
    add_action kube-restart "restart resource(s)"
    add_action kubectl --collect "generic kubectl in the right cluster and namespace of all targets"
    add_option R replicas nr  "specify number of replicas"
    global_vars+=" kube_cluster namespace"
    global_arrays+=" kube_resource_alias kube_default_replicas"
}

parse_option_resource()  { kube_resource_list+=" $2"; parse_result=2; }
parse_option_replicas()  { kube_replicas="$2";  parse_result=2; }


kubectl_options() {
    local cl=${kube_cluster}
    local cfg=${kube_config_map[$cl]:-default}
    local opt=""
    if [[ $cfg != default ]]; then
        opt="--kube_config_map $cfg " # extra space at end
    fi
    opt+="--context ${kube_context_map[$cl]} -n $namespace"
    echo $opt
}

filter-kube-diff-output() { grep -E '^[+-] |^---'; }
run_action_kube-diff() {
    run_action_render
    info kube-diff ${target} to ${output_dir}
    if $(log_is_verbose); then
        verbose_cmd kubectl diff $(kubectl_options) -f $output_dir || true
    else
        verbose_pipe filter-kube-diff-output kubectl diff $(kubectl_options) -f $output_dir || true
    fi
}

run_action_kube-apply() {
    run_action_kube-diff
    info kube apply $output_dir
    verbose_cmd kubectl apply $(kubectl_options) -f $output_dir
}

run_action_kubectl() {
    info kubectl $output_dir
    verbose_cmd kubectl $(kubectl_options) $extra_args
}


split_kubectl_output_into_files() {
    yq  '.items.[]' -s \"$output_dir/\"'+ (.kind | downcase) + "_" + .metadata.name + ".yaml"'
}

run_action_kube-get-manifests() {
    info kube get manifests  ${target} to ${output_dir}
    verbose_cmd rm -rf ${output_dir}
    verbose_cmd mkdir -p ${output_dir}
    verbose_pipe split_kubectl_output_into_files kubectl ${kubectl_options[$kube_cluster]} -n "${namespace}" get deploy,svc,sts,cm,ingress -o yaml
    ignore_files=configmap_kube-root-ca.crt.yaml
    ignore_files+=" deployment_ingress-nginx-controller.yaml"
    ignore_files+=" service_ingress-nginx-controller-admission.yaml"
    ignore_files+=" service_ingress-nginx-controller.yaml"
    for f in ${ignore_files}; do
        rm -f "${output_dir}/$f"
    done
    for f in "${output_dir}"/*.yaml; do
         yq -i 'del(.metadata.annotations.["kubectl.kubernetes.io/last-applied-configuration"])' "${f}"
         yq -i 'del(.metadata.uid)' "${f}"
         yq -i 'del(.metadata.resourceVersion)' "${f}"
         yq -i 'del(.metadata.creationTimestamp)' "${f}"
    done
}

run_action_kube-get() {
    verbose_cmd kubectl $(kubectl_options) -n $namespace get ${extra_args:-pods,deploy,sts,cm}
}
run_action_kube-watch() {
    verbose_cmd watch kubectl $(kubectl_options) -n $namespace get ${extra_args:-pods,deploy,sts,cm}
}
run_action_kube-restart() {
    local res
    for res in ${kube_resource_list//,/ }; do
        res=${kube_resource_alias[$res]:-$res}
        verbose_cmd kubectl $(kubectl_options) -n $namespace rollout restart $res
    done
}
run_action_kube-tmp-scale() {
    local res
    for res in $(calc_resource_names); do
        verbose_cmd kubectl $(kubectl_options) -n $namespace scale $res --replicas $(calc_kube_replicas $res)
    done
}

calc_resource_names() {
    local result=${kube_resource_list:-all}
    if [[ $result == all ]]; then
        result=${all_resources}
    fi
    echo ${result//,/ }
}

calc_kube_replicas() {
    local repl=${kube_replicas:-default}
    if [[  $repl == default ]]; then
        repl=${kube_default_replicas[$1]}
    fi
    echo $repl
}

#####################################
# kustomize.bash

render_kustomize() {
    local command="kubectl kustomize --enable-helm"
    #used_files+=" $helm_chart_dir/$ch"
    verbose_pipe split_into_files "$command ${karmah_dir}"
}

#####################################
# render.bash

init_bash_module_render() {
    add_action render "render manifests to --to <path> (default tmp/manifests)"
    add_action compare "render manifests to --to <path> (default tmp/manifests) and then compare with --with path (default deployed/manifests)"
    global_vars+=" renderer output_dir"
    declare -g to_dir
    add_option s subdir   dir   "add subdir to list of subdirs (can be comma separated list)"
    add_option t to       path  "other path to render to (default is tmp/manifests)"
    add_option w with     path  used for comparison between two manifest trees
}

parse_option_subdir()    { subdirs+=" $2"; parse_result=2; }
parse_option_to()        { to_dir="$2"; parse_result=2; }
parse_option_with()      { with_dir="$2"; parse_result=2; }


run_action_render() {
    run_action_update
    info rendering ${target} with ${renderer} to ${output_dir}
    verbose_cmd rm -rf ${output_dir}
    verbose_cmd mkdir -p ${output_dir}
    for r in ${renderer//,/ }; do
        render_$r
    done
 }

run_action_compare() {
    run_action_render
    olddir=${output_dir}
    local newdir=${with_dir:-deployed/manifests}/${target}
    info comparing ${target}: ${output_dir} with ${newdir}
    verbose_cmd diff -r $newdir $olddir || true
}

split_into_files() {
    yq -P 'sort_keys(..)' | yq -s \"$output_dir/\"'+ (.kind | downcase) + "_" + .metadata.name + ".yaml"'
    rm -f ${output_dir}/_.yaml
}

#####################################
# update.bash

init_bash_module_update() {
    add_action update "update source files with expressions from --update"
    add_option V version ver  "specify version (tag) to use for update or scale"

    global_vars+=" update_version_function update_replicas_function"
    aliases[tmp-stop]="--action kube-tmp-scale --replicas 0"
    aliases[tmp-start]="--action kube-tmp-scale --replicas default"
    aliases[stop]="--action deploy --replicas 0"
    aliases[start]="--action deploy --replicas default"
}

parse_option_version()   { update_version="$2"; parse_result=2; }


run_action_update() {
    local any_updates=false
    if [[ ! -z ${update_version:-} ]]; then
        #info update $target version to $update_version
        ${update_version_function:-default_update_version}
        any_updates=true
    fi
    if [[ ! -z ${kube_replicas:-} ]]; then
        #info update $target replicas to $kube_replicas
        ${update_replicas_function:-default_update_replicas}
        any_updates=true
    fi
    $any_updates || verbose no updates detected
}

default_update_version() {
    local r
    local any_updates=false
    for r in ${renderer//,/ }; do
        if [[ $(type -t update_version_$r) == function ]]; then
            info updating $target version in $r to $update_version
            update_version_$r
            any_updates=true
        else
            debug skipping update version $r
        fi
    done
    $any_updates || warn no updates performed for version to $update_version
}

default_update_replicas() {
    local r
    local any_updates=false
    for r in ${renderer//,/ }; do
        if [[ $(type -t update_replicas_$r) == function ]]; then
            info updating $target replicas in $r to $kube_replicas
            update_replicas_$r
            any_updates=true
        else
            debug skipping update replicas $r
        fi
    done
    $any_updates || warn no updates performed for replicas to $kube_replicas
}

#####################################
# actions.bash
# run actions for all targets

init_bash_module_actions() {
    add_command "forall" "run actions for all targets"
    add_action ask "ask for confirmation (unless --yes is specified)"
    add_action deploy "render to deployed/manifests and optionally deploy to kubernetes"
    add_option a action act  add action to list of actions to perform
    add_option y yes    ""   do not ask for confirmatopm

    command=run_command_forall
    declare -g global_vars="karmah_type target"
    declare -g global_arrays=""
    yes_arg=""
}

parse_option_action() { action_list+=" $2"; parse_result=2; }
parse_option_yes()    { yes_arg="--yes"; }

run_action_ask() {
    if [[  $yes_arg == --yes ]]; then
        verbose skipping ask, because --yes is specified
        return 0
    fi
    local answer
    read -p "do you want to continue [y/N]? " answer
    if [[ "${answer}" != y ]] ;then
        info "Stopping karmah"
        exit 1
    fi
}


run_command_forall() {
    for path in $karmah_paths; do
        if [[ -f $path ]]; then
            karmah_file=$path
            run_karmah_file
        elif [[ -z ${subdirs:-} ]]; then
            karmah_file=($path/*.karmah) # use array for globbing
            run_karmah_file
        else
            for sd in ${subdirs//,/ }; do
                karmah_file=($path/$sd/*.karmah)  # use array for globbing
                run_karmah_file
            done
        fi
    done
}

init_karmah_type_basic() {
    verbose using empty karmah_type initializer
}

run_karmah_file() {
    local karmah_type
    if [[ -f "${karmah_file}" ]]; then
        # cleanup of any vars that might have been set with previous file
        debug clearing $global_vars $global_arrays
        unset $global_vars $global_arrays
        declare -g $global_vars
        declare -gA $global_arrays
        verbose loading ${karmah_file}
        local karmah_dir=$(dirname $karmah_file)
        local common_dir=$(dirname $karmah_dir)/common
        local used_files=${karmah_dir}
        local common_karmnah_file=($common_dir/common*.karmah)
        if [[ -f $common_karmnah_file ]]; then
            source $common_karmnah_file
        fi
        source ${karmah_file}
        init_karmah_type_${karmah_type:-basic}
        output_dir="${to_dir:-tmp/manifests}/${target}"
        run_actions ${action_list:-render}
    else
        info skipping $karmah_file
    fi
}

run_action_deploy() {
    output_dir="${to_dir:-deployed/manifests}/${target}"
    local actions=${deploy_actions:-render,git-diff,ask,git-commit}
    info deploying ${output_dir} with actions: ${actions}
    # TODO: output_dir is different for actions before this action
    run_actions $actions
}

run_actions() {
    for action in ${@//,/ }; do
        verbose running $action for ${target}
        run_action_$action;
    done
}

#####################################
main "${@}"
